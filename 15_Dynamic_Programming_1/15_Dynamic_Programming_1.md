# 15_Dynamic_Programming_1

## 목차

### [1. 2156. 포도주 시식](#2156.포도주시식)





## [2156.포도주시식](https://www.acmicpc.net/problem/2156)

### 풀이 코드

```python
from typing import List

N: int = int(input())
wines: List[int] = [int(input()) for _ in range(N)]

dp: List[int] = [0] * N
dp[0] = wines[0]
if N >=2:
    dp[1] = wines[0] + wines[1]

    for i in range(2, N):
        dp[i] = max(dp[i-1], dp[i-3] + wines[i-1] + wines[i], dp[i-2] + wines[i])

print(dp[-1])
```



### 주절주절

* DFS는 뭔가 외워서 푸는 느낌이 들어서 다른 유형의 문제를 풀려고 해봤습니다.

    대부분 정답으로 되어있는데 (이전에 풀어서)

    이 문제는 실패로 되어있더라고요.. 그래서 골랐습니다.

* 문제를 풀기 전에 로직을 써보는 습관이 생겼습니다. 정말 좋은 습관이네요.

    1. 이번 포도주를 안 마신 경우 : `dp[i-1]` (이전 것 그대로)
    2. 이번 포도주를 마신 경우
        1. 이전 포도주를 마신 경우 : `dp[i-3] + wines[i-1] + wines[i]` (3번 전의 최대 + 이전 포도주 + 이번 포도주)
        2. 이전  포도주 안 마신 경우 : `dp[i-2] + wines[i]` (2번 전의 최대 + 이번 포도주)

* 위 3가지 경우 중 가장 큰 것이 지금 순서에서의 최댓값이라서 그걸 계산하면서 빈칸을 채워갔습니다.

* DP 문제는 처음에 볼 때는 이걸 어떻게 하지? 하는데

    순서대로 적어가다 보면 의외로 쉽게 풀리는 문제들인 것 같습니다.

* 뭔가 지금 알고리즘 공부하는 것과 똑같네요.

    처음에는 어떻게 다시 시작하지라고 했는데 어느새 3일째 알고리즘 문제를 정말 빠르게 풀어내고 있습니다.

    시작하는 게 중요하군요

* 사실 이 문제는 한번에 통과하지는 못 했습니다.

    제출을 누르고 뭔가 이상한 느낌이 들어서 문제 조건을 보니까 N>=1 이라고 되어있더라고요.

    '아... `dp[1] = wines[0] + wines[1]`를 헀으니 N이 1이면 런타임 에러가 뜨겠구나...' 라고 생각하며

    겸허히 런타임 에러를 받아들였습니다.

    그리고 빠르게 다음 줄을 추가해버렸습니다.

    ```python
    if N >=2:
    ```

    